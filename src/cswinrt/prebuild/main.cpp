#include "pch.h"

struct writer : cswinrt::writer_base<writer>
{

};

int main(int const argc, char** argv)
{
    if (argc < 3)
    {
        puts("Usage: prebuild.exe input output");
        return 0;
    }

    auto const strings_dir = std::filesystem::path(argv[1]);
    auto const additions_dir = strings_dir / "additions";

    writer strings_h;
    writer strings_cpp;

    strings_h.write(R"(// cswinrt static string declarations. This file was generated by the build.
#pragma once
namespace cswinrt::strings
{
)");

    strings_cpp.write(R"(#include "strings.h"
namespace cswinrt::strings {
)");

    struct entry
    {
        std::string key;
        std::string global;
    };

    std::vector<entry> base_entries;
    std::vector<entry> addition_entries;

    auto write_string = [&](std::filesystem::path const& path, std::string const& global)
    {
        auto view = cswinrt::file_to_string(path.string());

        strings_h.write(R"(    extern char const %[];
)",
            global);

        strings_cpp.write(R"(extern char const %[] = R"xyz()xyz"
)",
            global);

        std::string_view remainder = view;

        while (!remainder.empty())
        {
            auto const size = std::min(size_t{ 16'000 }, remainder.size());
            auto const chunk = remainder.substr(0, size);

            strings_cpp.write(R"(R"xyz(%)xyz"
)",
                chunk);

            remainder = remainder.substr(size);
        }

        strings_cpp.write(R"(R"xyz(
)xyz";
)");
    };

    for (auto&& file : std::filesystem::directory_iterator(strings_dir))
    {
        if (!std::filesystem::is_regular_file(file))
        {
            continue;
        }

        auto path = file.path();
        auto name = path.filename();
        name.replace_extension();

        auto global = name.string();
        for (auto& c : global) { if (c == '.') c = '_'; }

        write_string(path, global);
        base_entries.push_back({ name.string(), global });
    }

    strings_h.write(R"(    static const struct
    {
        char const* name;
        char const* value;
    } base[] = {
)");
    {
        std::string delimeter;
        for (auto&& e : base_entries)
        {
            strings_h.write("        %{\"%\", %}\n", delimeter, e.key, e.global);
            delimeter = ", ";
        }
    }
    strings_h.write("    };\n");

    if (std::filesystem::exists(additions_dir))
    {
        for (auto&& ns_dir : std::filesystem::directory_iterator(additions_dir))
        {
            if (!std::filesystem::is_directory(ns_dir))
            {
                continue;
            }

            auto ns_name = ns_dir.path().filename().string();

            for (auto&& file : std::filesystem::directory_iterator(ns_dir.path()))
            {
                if (!std::filesystem::is_regular_file(file))
                {
                    continue;
                }

                auto path = file.path();
                auto name = path.filename();
                name.replace_extension();

                auto ns_part = ns_name;
                for (auto& c : ns_part) { if (c == '.') c = '_'; }
                auto file_part = name.string();
                for (auto& c : file_part) { if (c == '.') c = '_'; }
                auto global = ns_part + "_" + file_part;

                write_string(path, global);
                addition_entries.push_back({ ns_name, global });
            }
        }
    }

    strings_h.write(R"(    static const struct
    {
        char const* name;
        char const* value;
    } additions[] = {
)");
    {
        std::string delimeter;
        for (auto&& e : addition_entries)
        {
            strings_h.write("        %{\"%\", %}\n", delimeter, e.key, e.global);
            delimeter = ", ";
        }
    }
    strings_h.write("    };\n");

    strings_h.write("}\n");

    strings_cpp.write(R"(
}
)");

    writer version_rc;

    version_rc.write(R"(
#include "winres.h"

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 0,0,0,0
 PRODUCTVERSION 0,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x0L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Microsoft Corporation"
            VALUE "FileDescription", "C#/WinRT"
            VALUE "FileVersion", "0.0.0.0"
            VALUE "LegalCopyright", "Microsoft Corporation. All rights reserved."
            VALUE "OriginalFilename", "cswinrt.exe"
            VALUE "ProductName", "C#/WinRT"
            VALUE "ProductVersion", "%"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END
)",
    CSWINRT_VERSION_STRING);

    std::filesystem::create_directories(argv[2]);
    auto const output = std::filesystem::canonical(argv[2]);
    strings_h.flush_to_file(output / "strings.h");
    strings_cpp.flush_to_file(output / "strings.cpp");
    version_rc.flush_to_file(output / "version.rc");
}
